\label{Design}
\chapter{Design Choices}
This chapter will cover the various design choices we had to make during the project. We explain why we implemented features the way we did, or why we chose not to persue some of the initial goals. 

\section{Repast Symphony}
An initial requirement set by the client was the full implementation of Repast. Repast is a agent simulation toolkit. BW4T uses very small parts of its functionality, though heavily extended and modified. Repast offers various advanced simulation functionality, which could be interesting for a program like BW4T. We investigated the possibilities of implementing a lot more of this functionality. Unfortunately, BW4T was not built from the ground up with Repast in mind. This resulted in some basic framework use, with custom classes replacing most of Repast's real functionality. Because of the nature of both BW4T and Repast, it is very difficult to implement more Repast functionality in BW4T without breaking some of the current functionality. It should be possible, but not without a very very thorough restructure, or a complete rebuild from the ground up. \\

This was not feasible for the Contextproject due to the lack of time and experience. Therefore we decided to leave the current Repast integration untouched. We did however upgraded to the latest version of Repast, and fixed the massive dependency on the entire Repast project. Instead, the libraries were extracted and added as a project dependency, resulting in a drastic decrease of download size. 

\section{Maven and Code split} %Add source, wiki 
In the BW4T v2 code base, all the code was in a single folder/package structure. Code for the server, client, environment and all the other tools all resided in a single project. Because of this, getting a clear overview of the project structure was very hard. To resolve this, all separate sections were split into separate projects. This resulted in a separate project for the Server and the Client. Some of the code is shared between the projects. To avoid mutual dependencies, a 3rd project was created. The Core project contains code that is shared between all projects within BW4T. 

All these projects can be seperately built, tested and released as a jar file. This also greatly improves the general structure and maintainability of BW4T. In order to simplify the whole build-test-release process, we also converted these seperate projects to Maven. A "parent" project was created to build all projects at once. This project does not contain code for BW4T, but manages the checkstyle, project hierarchy and dependencies. 

Maven is a build automation tool used primarily for Java projects. Maven addresses two aspects of building software: first, it describes how software is built, and second, it describes its dependencies. Contrary to preceding tools like Apache Ant it uses conventions for the build procedure, and only exceptions need to be written down. An XML file describes the software project being built, its dependencies on other external modules and components, the build order, directories, and required plug-ins. It comes with pre-defined targets for performing certain well-defined tasks such as compilation of code and its packaging. Maven dynamically downloads Java libraries and Maven plug-ins from one or more repositories such as the Maven 2 Central Repository, and stores them in a local cache. This local cache of downloaded artifacts can also be updated with artifacts created by local projects.

For each of the additional features like the bot store and scenario GUI, a seperate project was also created and added to the parent project. This results in a lot of seperate project directories in the IDE, but the greatly improved overview and manageability compensates for this. 

\section{GitHub}
The original BW4T project used SVN, and was hosted on a local SVN repository. For BW4Tv3, we switched to a different kind of version control; Git, hosted on GitHub. Git is more suitable for large groups working on the same projects by working with branches. Branches are copies of the codebase, in which you can make changes parallel to the main branch. After you implemented a feature or applied the intended changes, you can merge the code with the main branch. By working in these branches you make sure that no two persons can undo others work by accidentally overwriting each others work. GitHub warns you when you request for merge, that two pieces adjusted by different people and that you might want to take a closer look at the differences before merging it. This is a clear advantage over SVN, and one of the reasons we switched to Git.\\
GitHub also offers various improvements over a self-hosted repository. Because of the public nature of the site, documentation is improved because it shows a good and clear history of the project. It documents the various issues, commits, pull requests and has a built in wiki for manual documentation purposes. Therefore changes made by others are easily seen and reverted if needed, and over-all documentations and "How-to's" can easily be viewed by the entire project group.

\section{Logger}
BW4T used a custom logger to track some agent actions. This was not very flexible, and had to be manually extended when more functionality was required. We chose to replace this with an existing logging solution, namely Log4J. This standard logger package is included in the Java libraries, so it does not cause an extra dependency. It allows for a lot more flexibility in log levels (i.e. Debugging, Warning, Error) and is very easy to call from anywhere in the project. This way, you can add logging to almost any part of the project when desired. The logger writes different levels to to the console, but only the highest level to a file. Ofcourse, this is configurable if desired. 

\section{Message Translator}
Most of the refactoring done were relatively simple method extracts and if/else optimisations. One class however, was completely overhauled because of its excessive complexity. MessageTranslator.java is responsible for translating Strings to BW4TMessages, BW4TMessages to String, and BW4TMessage to Parameters, all used to interact with GOAL. This was done using 3 methods, all with a huge if/else tree, manually returning the right translation. In order to reduce cyclomatic complexity, the class was refactored to the Command-pattern. This comes down to using Hashmaps to look up the right action, instead of going through the entire if/else tree each time the method is called. Especially for the BW4TMessage-to-String and BW4TMessage-to-Parameter, this results in a big performance increase, next to a much clearer method. \\

For the String-to-BW4TMessage method, a Hashmap<String, Command> was created. All strings previously checked in the if/else tree, now have their own entry in the map. The Command interface defines a standard getMessage() method, returning the right BW4TMessage upon executing. 

For the other 2 methods, a similar Hashmap<MessageType, Command> was created. Each MessageType has its own Command, defined in MessageCommand.java. The interface defines two functions, getString() and getParameter(), returning the right translation upon execution. 

This new approach results in a big MessageCommand file, because each MessageType has its own command, but this makes finding bugs, adding MessageTypes, and changing behaviour much simpler.

\section{Analysis Tools}
To analyse code quality, and to make it easier to determine where to start, we used several analysis tools. We mostly used SonarQube, a web-based tool that analyses the code after each change to the master branch on GitHub. It analyses a large number of software metrics and tracks a lot of issues, subdivided in severance (Blocking, Critical, Major, etc.) We used Sonar to determine classes and methods with excessive complexity, checkstyle errors that can lead to bugs and other violated best practices. Next to that, it tracks test coverage, unneeded dependencies, duplicate code.

inFusion is a similar program that you have to run manually. It provides similar metrics as Sonar, but focuses less on issues. Instead, it points out problems with classes as a whole, next to problems with entire methods. 